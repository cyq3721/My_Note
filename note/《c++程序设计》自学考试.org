#+title:Shadow-fish's Notebook
#+author:ShadowFish
#+data: [2019-01-12 Sat]

* 第一章 认识C++的对象
** 混合型语言
C++程序以 .cpp 作为文件的扩展名， 并且必须有一个且只能有一个名为main（不是C++的关键字）的主函数。  真正的面向对象语言是没有主函数的，C++保留了这个面向过程的主函数， 所以称之为混合型语言。
** 灵活的注释方式
- c语言的多行注释  
#+BEGIN_QUOTE
/* …… */
#+END_QUOTE
- c++的单行注释
#+BEGIN_QUOTE
//
#+END_QUOTE
** 使用输出和输入对象
- C++将数据从一个对象流向另一个对象的流动抽象为”流“。 从流中获取数据的操作称为提取操作。
- cin>>       输入 
- cout<<      输出
- cin和cout都不是c++语言本身定义的一部分， 而是由C++的一套面向对象类体系提供支持并作为C++标准程序库的一员，所以在使用它们之前，需要在主函数前使用#include语句将其包含。C++标准输入输出库的头文件是iostream。
- cout<<endl; 和 cout<< "\n";  都是换行。
** 使用命名空间
c语言一直使用.h标识头文件， 新的C++标准引入了新的标准类库的头文件载入方式， 省略.h，但是必须使用命名空间： 
#+BEGIN_QUOTE
using namespace std;
#+END_QUOTE
** 对象的定义和初始化
用构造函数语法进行初始化
- int z（0）；   相当于int z = 0；
- int b（50）；  相当于int b = 50；
** 函数原型及其返回值
- 函数调用在函数之前时要对函数进行声明；
- 函数都需要有类型说明。 int main（）指出main是整数类型，返回值由return后面的表达式决定，且表达式的值必须与声明的函数的类型一致。 若函数没有返回值，可以使用：return 0；
- void 表示函数不需要返回值，此时，return后不能跟任何表达式，只能单独使用return；
- C++的函数有库函数（标准函数）和自定义函数两类。
- 函数原型：int result （int， int）；  函数原型只需要说明变量的类型和个数，不需要说明变量的名称。 
** const修饰符和预处理程序
- C语言中使用宏定义”#define“定义常量，在C++中使用const代替宏定义。  用关键字const修饰的标识符是一类特殊的常量，称为符号常量，或const变量。
- 常量的定义：const int k（2）；    等价于const int k = 2；
- 因为const常量在程序中不能被改变，所以在声明时必须直接进行初始化，给出一个初始值。 extern外部变量例外。 例如：const int d；  这个是错误的，没有初始化。extern const int d ； 这个是可以的。
** 三种预处理
- 宏定义
- 文件包含
- 条件编译
** 函数重载
函数重载要点：
- 函数名相同；
- 参数个数不同；
- 参数类型不同；
** c++的新数据类型
- void类型：不能声明变量，只能声明函数返回值。表示函数无返回值。
- bool类型（逻辑类型）：占1个字节，表示逻辑运算中的”真“和”假“。
- 整型（int  long    short）：int 、short  至少16位；long至少32位；int不得比long长。
- char类型（字符型）：占一个字节。
- 实型（float/double/long double)
- & 取地址符
- 指针变量能存放变量的地址
- 常量表示：整型：o前缀表示8进制数，0x前缀表示16进制，L、l后缀表示长整型常量。
** 动态分配内存
*** 使用格式
指针变量=new 类型[size];  
#+BEGIN_QUOTE
int *p = new int[3];   分配3个整型内存空间给p
……
delete p；  //释放内存
#+END_QUOTE
** 引用
引用就是使用变量的别名。
- 定义形式： 数据类型 &别名 = 对象名；（注意等号右边的对象必须事先初始化）
- 作用：别名与对象名对应同一个对象，共用同一段内存。对别名的修改会造成原对象的修改。如：int x； int &a = x； 表示a是变量x的别名。一旦定义别名后则a和x完全等价。引用和被引用的对象共用一个内存地址。
- 引用的注意点：
  + 不能定义引用的引用。
  + 不能直接定义对数组的引用，但可以使用typedef间接引用数组
#+BEGIN_QUOTE
typedef int array[10];
array a;
array &b = a;
#+END_QUOTE
  + 使用typedef定义某类型别名后，可以使用该别名来定义相关对象。如：typedef long int lint；
lint i；  等价于long int i；
  + 可以声明对指针的引用 int * &P1 = p2;
** 对指针使用const限定符
*** 指向常量的指针
int x = 11; const int *p = &x;(或 const int *p ;  const int *p = &x;)    表示*p是不能改变的。
*** 常量指针
int x = 11; int * const p = &x; (必须同时初始化)，表示p这个内存地址是不能改变的，该地址里的内容可以改变，即*p可以改变
*** 指向常量的常量指针
int x = 11; const int * const p = &x;  表示p不可改变，*p也不可改变。
** 泛型算法用于普通数组
泛型算法就是提供的操作与元素的类型无关
*** 操作和需要的头文件
- 升序排序、反转数组、复制数组 —— <algorithm>
- 降序排序、检索             —— <functional>
*** 数组内容的反转
reverse(a, a+len); 
*** 复制数组的内容
- copy(a,a+len,b);
- reverse_copy(a,a+len,b);
*** 数组升序排序
- sort(a,a+len);
*** 数组降序排序
- sort(b,b+len,greater<Type>());
*** 查找数组内容
- <Type> *p = find(a,a+len,value);  //返回字符的位置指针
*** 输出数组的内容
- copy(a,a+len,ostream_iterator<Type>(cout,"分割字符"));
- 字符串数组需要一个结束符，反转复制时要注意，不能将这个结束符反转复制，否则，反转后，字符串的第一位变成结束标志，就成了空字符串。
*** 数据的简单输入输出格式
**** C++提供了两种格式控制方式：
- iso_base类提供的接口
- 称为操控符的特殊函数，可以直接包含在输入、输出表达式中，更为方便。不带形式参数的操控符定义在有文件<iostream>中，带形式参数的操控符定义在头文件<iomanip>中。 使用时：
  - 正确包含头文件；
  - 只有与符号<< 或 >> 连接时才起作用；
  - 无参数的操控符不能带有（）；
**** 操控符及其含义
| 操控符                     | 含义                                                             |
| setw（int width）          | 设置输出的宽度，不足宽度，左边补充空格；大于宽度，照数字宽度输出 |
| setfill（char ch）         | 设置ch为填充字符                                                 |
| setprecision（int n）      | 设置浮点数的输出精度                                             |
| setiosflags(long flag)     | 设置flag指定的标志位                                             |
| resetiosflags（long flag） | 清除flag指定的标志位                                             |
| dec                        | 转换为10进制                                                     |
| oct                        | 转换为八进制                                                     |
| hex                        | 转换为十六进制                                                          |
** 编程题
1. 分别用字符和ASCII码形式输出整数值65和66.
   - 字符A的ASCII码为65，字符B的ASCII码为66.
   - 字符a的ASCII码为97
   - 数字1的ASCII码为49，数字5的ASCII码为53，数字6的ASCII码为54
   - ASCII码形式的输出：（int）‘A' （把A转换为ASCII的整数值65）
   - 字符形式的输出： （char）53  （把ASCII码53转化为字符5）
     
* 第二章 从结构到类的演变
** 结构的演变
*** 结构发生质的演变
**** 函数与数据共存
c++允许在结构中定义函数，这些函数称为成员函数。
#+BEGIN_QUOTE
struct 结构名{
      数据成员
      成员函数
};
#+END_QUOTE
**** 封装性
定义结构时，用private关键字定义数据成员，则产生封装性。c++的结构的数据成员和成员函数默认为public
**** 使用构造函数初始化对象
*** 从结构演变为类
*** 面向过程与面向对象
- c语言是结构化程序设计语言， 其程序设计特点就是函数设计。  函数就是模块的基本单位， 是对处理问题的一种抽象。  一个函数就是一个程序模块，程序的各个部分除了必要的信息交流之外，互不影响， 相互隔离的程序设计方法就是模块化程序设计方法。
- 面向过程设计存在的问题：
  - 要求开发人员按计算机的结构去思考，而不是按要解决的问题的结构去思考。
  - 开发人员必须在机器模型（解空间）和实际问题模型（问题空间）之间进行对应。
- 面向对象的优势：
  - 可以将一组密切相关的函数统一封装在一个对象中，从而可以有效的避免全局变量的使用。
  - 面向对象方法更加彻底的实现了结构化程序设计的思想。
  - 面向对象程序设计是功能抽象和数据抽象的统一。
  - 面向对象程序设计不是以函数过程和数据结构为中心，而是以对象代表求解问题的中心环节。追求的是现实问题空间与软件系统空间的近似和直接模拟。
** c++面向程序设计的特点
*** 特点
- 封装
- 继承
- 抽象
- 多态
*** 对象三要素
- 对象名 —— 标示一个具体对象
- 属性 —— 描述对象静态特征的一个数据项
- 操作 —— 描述对象的动态特征（行为）的一个函数序列（使用函数实现操作）。也称为方法或服务。
*** 对象的概念
是系统中用来描述客观事物的一个实体，是构成系统的一个基本单位。一个对象由一组属性和对这组属性进行操作的成员函数构成。
*** 抽象和类
抽象是从一般的观点看待事物的方法，集中于事物的本质特征，而不是具体细节或具体实现。将一组对象的共同特征进一步抽象出来，从而形成类的概念。类的属性只是性质说明，对象的属性才是具体的数据。
*** 封装
- 对象的属性只能由这个对象的操作
- 对象的操作分为内部操作和外部操作。内部操作只供对象内部的其它操作使用，不对外提供。外部操作对外提供一个消息接口，通过这个接口接收对象外部的消息并为之提供操作（服务）
- 对象内部数据的不可访问性称为 —— 信息（数据）隐藏。
- 封装就是把对象的属性和操作结合成一个独立的系统单位，并尽可能隐藏对象的内部细节。
- 在类中，封装是通过存取权限实现的。
*** 继承
继承是一个类可以获得另一个类的特性的机制，继承支持层次概念
*** 多态性
不同的对象可以调用相同名称的函数，获得完全不同的效果，这称为多态性。
** 使用类和对象
*** 使用string对象
**** string类的简化结构
| string   |
| str1     |
| ———————— |
| string   |
| find     |
| size     |
| substr   |
| swap     |
| begin    |
| end      |
**** stri\ng类的使用
- string类的对象必须用“”，不能用‘’。
- 对象名.成员函数
str1.size（），str1.find（）……
* 第三章 函数和函数模板
** 函数的参数及其传递方式
*** 简介
-  c语言的参数传递方式
  - 只有传值一种
    + 传变量值
    + 传变量地址值
- C++的参数的传递方式
  - 传值
  - 传引用
- 传地址和传地址值的区别
  - 传地址值传递的是值，不是地址，传地址传递的是地址不是地址值。
- 传递对象地址值
  - 使用对象指针作为参数。
— 传递对象地址 
  - 使用对象的引用作为参数。
-  参数
  - 可以使用对象、对象指针、对象引用作为参数。
*** 对象作为函数参数
将实参对象的值单向传递个形参对象，形参对象的改变不会影响实参对象。
*** 对象指针作为函数参数
将指向对象的指针作为函数参数，形参是对象指针（指针可以指向对象的地址），实参是对象的地址值。传递参数的方式仍然是传值方式。传递给形参的是实参本身（实参是形参地址相同），改变形参就是改变实参。传递对象地址值要用到对象的指针。数组名就是数组的指针名，所以数组能用传数组地址值的方式。
*** 引用作为函数参数
可以使用“引用”作为函数的参数，（引用形参）。这时函数并没有对形参对象初始化，即没有指定形参对象是哪个对象的别名。在函数调用时，实参对象名传递给形参，，形参对象名就成为实参对象的别名。实参对象和形参对象代表同一对象，改变形参，也就改变了实参。 

实际上，在虚实结合时，是把实参对象的地址传递个形参对象，使形参对象的地址取实参对象的地址，从而使形参对象和实参对象共享同一个地址单元。 这就是地址传递方式。

在说明引用参数时，不需要提供初始值，其初始值在函数调用时由实参对象提供。
*** 传指针和传引用的区别
传引用不单独占用内存单元， 而传指针要另外开辟内存单元（其内容是地址），所以传引用比传指针更好。
*** 默认参数
默认参数就是不要求程序员设定该参数，由编译器在需要时时给该参数赋默认值。 当程序员组要传递特殊值时，必须显示的指明，不能使用默认参数。

默认参数是在函数原型中说明的， 默认参数可以多于一个，但必须放在参数序列的后部。 

如果一个默认参数需要指明一个特定值，则在其之前的所有参数都必须赋值。
*** 使用const保护数据
用const修饰传递参数，意思是通知函数，它只能使用参数而无权修改它。 这主要是为了提高系统的安全性，C++中普遍使用这种方式。
** 深入讨论函数返回值
c++函数的返回值类型可以是除数组和函数以外的任何类型。 非void类型的函数必须向调用者返回一个值。 数组只能返回地址

当函数返回值是指针或引用对象时，需要特别注意：
- 函数返回所指的对象必须继续存在，因此不能将函数的内部的局部对象作为函数的返回值。
*** 返回引用的函数
函数可以返回一个引用， 主要目的是将函数使用为左值（放在赋值号的左边）。 函数原型的表示如下：
#+BEGIN_QUOTE
数据类型 & 函数名（参数列表）；
#+END_QUOTE
案例分析：
#+BEGIN_EXAMPLE
include <iostream>
using namespace std;

int a;

int & fuzhi(int & );

int main(){
  fuzhi(a) =5;
  cout<<"a="<<a<<endl;
}

int & fuzhi(int & i){
  return i;
}
#+END_EXAMPLE
**** 说明：
- 使用引用作为函数参数，是为了让形参i ，成为实参a（全局变量）的别名。如果不使用形参，那么形参i和实参a没有半点关系，而i只是函数的局部变量，当函数这个i后，在主函数，i没有定义，会出错。
— 返回类型为引用，是为了让函数fuzhi（）能够成为左值，能被赋值，使得fuzhi（a）=5，相当于a=5，fuzhi（a）的返回值为a。
- 把a定义为全局变量是因为，函数的返回类型为引用，那么返回值必须在主函数中存在，即返回值不能是函数的局部变量，必须是全局变量。
*** 返回指针的函数
函数的返回值可以是存储某种类型数据的内存地址（例如变量的地址、数组的首地址及指针变量的地址），称这种函数为指针函数。 他们一般定义形式如下：
#+BEGIN_QUOTE
类型标识符  *函数名（参数列表）；
#+END_QUOTE

内存分配失败时，函数会返回一个空指针值，这个值可以作为程序异常的标志。 因为在c++中，除了内存分配失败以外，new不会返回空指针值， 且没有任何对象的地址值为零。

** 函数重载和默认参数
函数重载可以使一个函数名具有多种功能，即具有多种形态，这种特性称为多态性。
** 函数模板
*** 引入函数模板
**** 函数模板示例
#+BEGIN_EXAMPLE
template <class T>
T max(T &m1,T &m2){
   retrun (m1>m2)? m1:m2;
}
#+END_EXAMPLE
**** 注意点：
- 参数必须是引用，否则，无法通过编译。
- c++中可以使用typename代替class

* 第四章 类和对象
** 类及其实例化
对象就是一类物体的实例，将一组对象的共同特征抽象出来，从而形成“类”的概念
*** 定义类
- 类先声明和使用；
- 类是具有唯一标示符的实体，类名是唯一的；
- 类中声明的任何成员不能使用extern、auto和register关键字进行修饰；
- 类中申明的变量属于该类；
- 不能在类声明中对数据成员使用表达式进行初始化；
- 默认是public
- 在申明类的同时，在类体内给出成员函数的定义，则默认为内联函数；
- 不能直接在类体内给数据成员赋值
**** 声明类
#+BEGIN_EXAMPLE
class 类名{
   private:
           私有数据和成员
   public:
           共有数据和成员
   protected:
           保护数据和成员
};
#+END_EXAMPLE
*** 使用类的对象
- 类的成员函数可以直接使用自己类的私有成员（数据成员和成员函数）；
- 类外面的函数不能直接访问类的私有成员；
*** 类定义对象指针
- 语法如下：
#+BEGIN_QUOTE
类名* 对象指针名；
对象指针名 = 对象的地址；
#+END_QUOTE
- 实例：
#+BEGIN_QUOTE
Point *p;
p = &B;
#+END_QUOTE
- 类对象的指针通过 -> 运算符访问对象的成员。
*** 数据封装
面向对象的程序设计是通过为数据和代码建立分块的内存区域以便提供对程序进行模块化的一种程序设计方式，这些模块可以被用作样板，在需要时再建立其副本。根据这个定义，对象就是计算机内存中的一块区域，通过将内存分块，每个模块（即对象）在功能上保持相对独立。
- 面向对象的程序中，只有向对象发送消息才能引用对象的行为，例如通过Display发送显示消息，才能引用显示这个行为，所以说面向对象是消息处理机制。
- 对象之间只能同构成员函数调用实现相互通信。
- c++对其对象的数据成员和成员函数的访问是通过访问控制权来限制的。
- c++通过类实现数据封装，通过指定各个成员的访问权限来实现，讲数据成员说明为私有，实现隐藏数据。将部分成员函数指定为public，实现和外界交互的接口。
** 构造函数
构造函数自动对对象进行初始化，初始化和赋值是不同的操作。
*** 默认构造函数
- 没有定义任何构造函数时，c++会自动建立一个不带参数的构造函数，函数名和类名相同。如：Point：：Point{}, 它的函数体是空的。
- 一旦程序定义了自己的构造函数，系统就不再提供默认构造函数。如果此时，程序员没有再定义一个无参数的构造函数，但又声明了一个没有初始化的对象，如Point A； ，此时，编译系统会因为系统不再提供默认构造函数，而自己又没有再定义一个不带参数的构造函数，从而造成编译错误，所以，必须定义一个不带参数的构造函数。
*** 定义构造函数
- 构造函数没有返回类型，也不用void;
- 初始化列表，如：Point：：Point（）：x（0），y（0）；
— 程序员不能在程序中显式的调用构造函数，构造函数是自动调动的。
*** 构造函数和运算符new
运算符new建立生存期可控的对象，new返回这个对象的指针，类名被看做一个类型名，使用new建立动态对象的语法和建立动态变量的语法一样。如：Point *ptr = new Point   （类名Point 相当于对象的类型）
*** 构造函数的默认参数
如果既想要定义自己的有参数的构造函数，又想使用无参数的默认的构造函数，解决办法是将相应的构造函数全部使用默认参数。
*** 复制构造函数
- 引用在类中一个很重要的用途是用在复制构造函数中。这是一类重要且特殊的函数，通常用于用已有的对象来建立一个新的对象；
- 为了安全，复制构造函数最好用const限定。
- 实例：
#+BEGIN_EXAMPLE
Point(Point&);
Point::Point(Point& t){
   x = t.x;
   y = t.y;
}

Point obj1(52,100);
Point obj2(obj1);
#+END_EXAMPLE
** 析构函数
在对象消失时，应使用析构函数释放由构造函数分配的内存。 构造函数、复制构造函数和析构函数是构造型成员函数的基本成员。
*** 定义析构函数
- 使用~符号定义析构函数
- 不指定返回类型
- 不指定参数，但可以使用void作为参数
- 析构函数在生存期结束时自动调用。
*** 析构函数和delete
- 定义个类数组 Point *ptr = new Point[2];
- 删除 delete []ptr;  注意[]的位置
** this指针
使用this指针，保证了每个对象可以拥有自己的数据成员，但处理这些数据成员的代码可以被所有的对象共享。  this指针是c++实现封装的一种机制，它将对象和该对象调用的成员函数连接在一起。
** 类和对象的性质
- 同一类的对象之间可以相互赋值。
- 可以使用对象数组。
- 可以使用指向对象的指针。如：Point *p = &A；
— 对象可以用作函数参数。
- 当对象作为函数参数时，可以使用对象、对象的引用和对象的指针
- 一个对象可以作为另一个对象的成员。
** 类的性质
*** 使用类的权限
- 类本身的成员函数可以使用类的所有成员（私有和公有）；
- 类的对象只能访问公有成员函数；
*** 不完全的类声明
- 类不是内存中的物理实体，只有当使用类产生对象时，才进行内存分配，这种对象建立过程称为实例化。  类必须在其成员函数使用之前先进行声明，然而，有时也需要将类作为一个整体来使用，而不是存取其成员。  申明指针就是这个情况。比如：
#+BEGIN_EXAMPLE
class MembersOnly;  //不完全的类声明
MembersOnly *club;  //定义一个全局变量的类指针
#+END_EXAMPLE
- 不完全类声明，用于在类没有完全定义之前就引用该类的情况。
- 不完全声明的类不能实例化。
*** 空类
空类可以产生空对象，如：
#+BEGIN_EXAMPLE
class Empty{};
int main(){Empty object;}
#+END_EXAMPLE
* 第5章 特殊函数和成员
** 对象成员的初始化
初始化const成员和引用成员时，必须通过成员初始化列表进行。
** 静态成员
- 声明中不含有const、volatile、static关键字的函数称为简单函数
- 静态成员只能说明一次，如果在类中对静态数据成员进行声明，则必须在文件作用域的某个地方进行定义。在进行初始化时，必须进行成员名限定。也可以直接在构造函数中使用成员限定符对其进行初始化。
- 静态成员在对象建立之前就存在。静态成员是类的成员，不是对象的成员。
- 在类中定义的静态成员是内联的。
** 友元函数
- 友元函数可以访问类的所有成员（包括私有）
- 友元的声明：
  - 在类本身中声明该类自身的友元
  - 在类a中，用类a的成员函数声明类b的友元
  - 将一个类说明为另一个类的友元
** const 对象
可以在类中使用const关键字定义数据成员和成员函数活修饰一个对象。  一个const对象只能访问const成员函数，否则将产生编译错误
*** 常量成员
常量成员包括：
- 常量数据成员（只能通过初始化列表来获得初始值）
- 静态常数据成员（保持静态成员特征， 需要在类外初始化。）
- 常引用（只能通过初始化列表来获得初始值）
*** 常引用作为函数参数
void Display(const double& r);   实参的值不能改变
*** 常对象
在对象声明前使用const，声明时必须同时进行初始化，而且不能被更新。例如：Base const a（25，31）；
*** 常成员函数
可以声明一个成员函数为const函数。 一个const对象可以调用const函数，但不能调用非const成员函数。 const成员函数声明时，const放在函数参数表之后。 例如： void show（）const；
** 指向类成员函数的指针
声明形式： type (A::*pointer)(list);  pointer = &A::value;

* 第7章 类模板和向量
** 向量和泛型算法
在数组生存期内，数组的大小是不会变的。 向量是一维数组的类版本，元素是连续存储的， 和数组不同的是：向量中存储的元素的多少可以在程序运行中根据需要动态的增长或减少。 向量是类模板，具有成员函数，如size（）动态的获得vector对象当前存储元素的数量。
*** 定义向量列表
- 向量提供4种构造函数；
   - vector<type> name;                   //定义类型为type的空的向量表;
   - vector<type> name(length);           //定义length个类型为type的向量，所有元素初始化为0；
   - vector<type> name(length,a);         //定义length个类型为type的向量，所有元素初始化为a；
   - vector<type> name1(name);            //用已经定义的向量name构造向量name1；
- 不能使用列表初始化向量， 可以先初始化一个数组，然后把数组内容复制给向量。如：
    #+BEGIN_EXAMPLE
    int IA[4] = {1,2,3,4};
    vetcto<int>VB(IA,IA+4);
    #+END_EXAMPLE
注意：不能用上述方法去初始化一个已经声明或定义过的向量。
*** 泛型指针
- 与操作对象的数据类型相互独立的算法称为泛型算法。
- 自定义标识符（typedef）
#+BEGIN_EXAMPLE
typedef int * it;    //用it替换 int * ;
int x = 6;
it p;
p = &x;
#+END_EXAMPLE
**** 用iterator 声明向量的泛型指针
 T 为向量的参数化的数据类型，iterator在STL中是一种通用指针，在向量中的作用相当于T*。用iterator声明向量的泛型指针的一般形式如下：
#+BEGIN_EXAMPLE
vector<type>::iterator 泛型指针名；
#+END_EXAMPLE
**** 用typedef自定义泛型指针的符号
#+BEGIN_EXAMPLE
tyepdef vector<type>::iterator iterator;
#+END_EXAMPLE
用iterator替代tyepdef vector<type>::iterator
**** 实例
#+BEGIN_EXAMPLE
tyepdef vector<int>::iterator iterator;
iterator p； //相当于int * p；
#+END_EXAMPLE
*** 向量的数据类型
- 基本数据类型
- 类和结构
- 构造类型
*** 向量的基本操作方法
**** 访问向量容量信息的方法
- size（）      返回当前对象中已近存放的对象的个数；
- max_size()   返回向量可以容纳的最多对象的个数；一般是操作系统的寻址空间能容纳的对象的个数，由硬件结构决定。
- capacity（）  返回无需再次分配内存就能容纳的对象个数，它的初始值是程序员最初申请的元素个数。当存放空间已满，又增加一个元素时，它在原来的基础上自动翻倍扩充空间，以便存放更多元素。
— empty（ ）    当向量为空时，返回true。
**** 访问向量中对象的方法
- front（）    返回向量中的第一个对象
- back（）     返回向量中最后一个对象
- operator[](size_type,n)  返回向量中第n+1个对象
**** 向向量中插入对象的方法
- push_back(const T&)   向向量尾部插入一个对象
- insert(iterator it , const T&) 向it所指向的向量位置前插入一个对象
- insert(iterator it,size_type n, const T&x) 向it所指向量位置前插入n个值为x的对象。
