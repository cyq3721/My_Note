
# &#30446;&#24405;

1.  [一、基本概念](#org0661f7a)
2.  [二、容器使用流程（以 Docker 为例）](#org2bad8a4)
3.  [三、主要优势](#orgff967ce)
4.  [四、常用工具与平台](#orgb308409)
5.  [五、典型使用场景](#orgc572d28)
6.  [六、注意事项](#org653e4e6)



<a id="org0661f7a"></a>

# 一、基本概念

****1. 什么是容器？****

-   容器是一种 **操作系统级别的虚拟化技术\*，用于将应用程序及其依赖（如库、配置、运行时等）打包成一个 \*轻量、可移植、自包含** 的运行单元。
-   容器在 **宿主机操作系统内核之上** 运行，通过命名空间（Namespaces）和控制组（Cgroups）实现资源隔离与限制。

****2. 容器 vs 虚拟机（VM）****

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">特性</th>
<th scope="col" class="org-left">容器</th>
<th scope="col" class="org-left">虚拟机（VM）</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">隔离方式</td>
<td class="org-left">进程级（Namespaces + Cgroups）</td>
<td class="org-left">硬件级（Hypervisor）</td>
</tr>

<tr>
<td class="org-left">内核</td>
<td class="org-left">共享宿主机内核</td>
<td class="org-left">每个 VM 运行独立操作系统内核</td>
</tr>

<tr>
<td class="org-left">启动速度</td>
<td class="org-left">秒级</td>
<td class="org-left">分钟级</td>
</tr>

<tr>
<td class="org-left">资源开销</td>
<td class="org-left">低</td>
<td class="org-left">高</td>
</tr>

<tr>
<td class="org-left">可移植性</td>
<td class="org-left">高（“一次构建，到处运行”）</td>
<td class="org-left">中</td>
</tr>

<tr>
<td class="org-left">典型代表</td>
<td class="org-left">Docker, Podman, containerd</td>
<td class="org-left">VMware, VirtualBox, Hyper-V</td>
</tr>
</tbody>
</table>

****3. 核心技术（Linux）****

-   \*Namespaces\*：隔离 PID、网络、挂载点、用户、UTS（主机名）等。
-   \*Cgroups\*：限制和监控 CPU、内存、磁盘 I/O 等资源使用。
-   \*UnionFS（如 OverlayFS）\*：支持分层镜像，实现高效构建与存储。


<a id="org2bad8a4"></a>

# 二、容器使用流程（以 Docker 为例）

****1. 编写 `Dockerfile`****

    FROM python:3.9-slim
    WORKDIR /app
    COPY . /app
    RUN pip install -r requirements.txt
    EXPOSE 8000
    CMD ["python", "app.py"]

****2. 构建镜像****

    docker build -t my-app:1.0 .

****3. 运行容器****

    docker run -d -p 8000:8000 --name my-app-container my-app:1.0

****4. 常用管理命令****

    docker ps                # 查看运行中的容器
    docker logs <容器ID>     # 查看日志
    docker stop <容器ID>     # 停止容器
    docker rm <容器ID>       # 删除容器
    docker images            # 列出本地镜像
    docker rmi <镜像ID>      # 删除镜像


<a id="orgff967ce"></a>

# 三、主要优势

-   ✅ \*环境一致性\*：消除“在我机器上能跑”的问题。
-   ✅ \*快速启动与部署\*：适合 CI/CD 和弹性伸缩。
-   ✅ \*资源高效\*：比 VM 更节省系统资源。
-   ✅ \*标准化交付\*：通过镜像实现应用打包与分发。
-   ✅ \*生态成熟\*：集成 DevOps、云原生工具链（如 Kubernetes、Helm）。


<a id="orgb308409"></a>

# 四、常用工具与平台

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">工具/平台</th>
<th scope="col" class="org-left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left"><b>Docker</b></td>
<td class="org-left">最流行的容器引擎，开发者友好</td>
</tr>

<tr>
<td class="org-left"><b>Podman</b></td>
<td class="org-left">无守护进程、支持 rootless 的 Docker 替代品</td>
</tr>

<tr>
<td class="org-left"><b>containerd</b></td>
<td class="org-left">CNCF 毕业项目，Kubernetes 默认运行时</td>
</tr>

<tr>
<td class="org-left"><b>Kubernetes (K8s)</b></td>
<td class="org-left">容器编排平台，用于大规模容器集群管理</td>
</tr>

<tr>
<td class="org-left"><b>Docker Compose</b></td>
<td class="org-left">本地多容器应用编排（开发/测试环境）</td>
</tr>
</tbody>
</table>


<a id="orgc572d28"></a>

# 五、典型使用场景

1.  \*微服务架构\*：每个服务独立容器化，便于开发、测试与部署。
2.  \*CI/CD 流水线\*：在容器中执行构建、测试、发布任务。
3.  \*本地开发环境\*：通过 `docker-compose.yml` 快速搭建数据库、Redis、消息队列等依赖。
4.  \*云原生应用\*：结合 Kubernetes 实现自动扩缩容、滚动更新、服务发现等。


<a id="org653e4e6"></a>

# 六、注意事项

-   **持久化数据\*：容器本身是临时的，需通过 \*卷（Volume）** 或绑定挂载（Bind Mount）保存数据。
-   \*安全性\*：
    -   避免以 `root` 用户运行容器。
    -   使用可信基础镜像，定期扫描漏洞（如 Trivy、Clair）。
-   \*日志与监控\*：集成集中式日志（如 ELK、Loki）和指标监控（如 Prometheus）。
-   \*不要滥用\*：容器不是虚拟机，不适合长期交互式操作或运行多个主进程。

> 📌 \*最佳实践\*：一个容器只运行一个主进程（Single Process Model）。

