#+title: linux就是这个范儿
#+author: CYQ
#+data:<2021-11-03 Wed>
#+LANGUAGE: zh-CN
#+html_head: <link rel="stylesheet" type="text/css" href="./css/worg-classic .css"/>
#+num: t
#+toc: 4
* 第一章 第一次亲密接触
** 不一样的图形操作
*** 没有图形的图形
Linux本身是没有图形界面的，Linux只是一个内核。 所有的类UNIX操作系统本身都没有图形用户界面。 
**** Linux通过一个软件提供图形界面
  - XFree86 （1992-2004）
  - xorg （2004年以后）
    2004年XFree86的开发商改变了软件按许可，引发GNU社区的极大不满，于是从XFree86 4.4 RC2衍生出了xorg。 目前几乎所开源的类Unix操作系统用的都是xorg。
**** X和xorg
X不是什么具体的软件，是一种协议，和http协议一样。 xorg是实现X协议的服务器软件，这个和实现http协议的Apache软件是一样的概念。 xorg通过X协议来提供图形用户界面服务。 Apache 的客户端请求Apache得到HTML内容， 而xorg可客户端请求xorg的结果是向屏幕上画图。 不同的是，Apache只能被动的接受客户端请求，而xorg还需要主动将当前键盘按键和鼠标位置等信息通知给客户端。
Linux上的那些拥有图形用户界面的软件实际上都是xorg的客户端，他们利用X协议让xorg在屏幕上画出窗口或通过xorg获得键盘和鼠标事件。
**** Window Manager (WM) —— 窗口管理器
是一类X协议客户端程序。 如：KDE、GNOME、XFCE …… 
**** Display Manager（DM） —— 显示管理器
负责图形界面的用户登录问题。 系统启动之后，第一个要启动的X客户端程序就应该是DM， DM也是一类软件，如：XDM、KDM、GDM …… 
*** 架构设计

** 主流桌面环境

| 桌面环境 | 特点             |
|----------+------------------|
| KDE      | 初学首先         |
| GNOME    | 经典             |
| XFCE     | 轻量、简单、高效 |
| LXDE     | 更轻量              | 

** 反璞归真的命令行
*** 执行命令
- 用户通过shell执行命令
- #和$提示符, 前者root后者普通用户
*** 文本和图形的切换
- ctrl+alt+f1～f6  ---------- 6个文本终端
- ctrl+alt+f7      ---------- 图形界面
*** 基础的命令操作

| 命令           | 说明                                                     |
|----------------+----------------------------------------------------------|
| 目录和文件处理 |                                                          |
| mkdir          | 建立目录                                                 |
| ls             | 列出目录下的内容                                         |
| cd             | 更换工作目录                                             |
| pwd            | 显示当前工作目录                                         |
| cp             | 拷贝文件和目录                                           |
| mv             | 移动（重命名）文件                                       |
| rm             | 删除目录或文件                                           |
| 文本处理       |                                                          |
| cat            | 显示到标准输出                                           |
| more           | 查看文件内容，满页时暂停                                 |
| less           | 和more类似，但是允许用方向键上下卷动                     |
| head           | 查看文件头部内容                                         |
| tail           | 查看文件尾部内容                                 |
| echo           | 显示一行文本，显示变量的内容               |
| 系统管理   |                                                          |
| ps             | 查看进程                                             |
| kill           | 删除执行中的程序或工作                                   |
| jobs           | 通过jobs命令查看后台正在执行的命令的序号（不是进程号id） |
| bg             | 指定号码（非进程号）的命令进程放到后台执行               |
| fg             | 指定号码（非进程号）的命令进程放到前台执行               |
| 文件系统       |                                                          |
| du             | 查看目录或文件所占用磁盘空间的大小                       |
| df             | 检查文件系统的磁盘空间占用                               |
*** 终端下的常用快捷键
| 常用快捷键 | 说明                 |
| tab        | 自动完成             |
| ctrl-a     | 光标移到命令的头部   |
| ctrl-e     | 光标移到命令的尾部   |
| ctrl-c     | 终止当前进程         |
| ctrl-s     | 终止终端传输         |
| ctrl-p     | 上一条执行的命令     |
| ctrl-n     | 下一条执行的命令     |
| ctrl-f     | 光标右移一个字符     |
| ctrl-b     | 光标左移一个字符     |
| alt-f      | 光标右移一个单词     |
| alt-b      | 光标左移一个单词     |
| ctrl-k     | 删除光标后的所有字符 |
| ctrl-d     | 删除光标前的所有字符 |
| alt-f1     | 开始菜单                 |
*** 联机帮助-man
Linux系统获取帮助的途径
- man
  浏览man的默认工具是less，翻页用Space，查找用/，用n查找下一个匹配项，用Shift——n查找前一个匹配项。
- info
- 命令名 -help
- 自带的readme文件或/usr/share/doc下的手册
* 第二章 融于心而表于行
** 多用户多任务分时操作系统
** 用户的身份
*** Linux下的用户只有两个等级
- root
- 非root
*** /etc/passwd 文件查看用户信息
- 文件名看和密码有关，但是不是的，现在保存密码的文件是/etc/shadow，也就是传说中的影子文件
- 一行代表一个用户，每一行由冒号：分割成7个字段，结构如下：

#+BEGIN_QUOTE
用户名：密码：UID：GID：用户全名：home目录：shell
#+END_QUOTE

*** /etc/group 文件查看组
结构如下:

#+BEGIN_QUOTE
组名：用户组密码：GID：用户组内的用户名
#+END_QUOTE

*** 管理用户和组
**** adduser或useradd两者的差异
- 在ubuntu中adduser是一个脚本，而useradd是一个二进制程序，前者对后者进行了封装，更加智能。但在centos中，两者完全一样，前者只是一个符号链接.
- useradd在任何发行版中都是一样的
**** useradd
一个经常使用的参数 -d （创建home目录）。eg:

#+BEGIN_QUOTE
useradd -d cyq  (创建用户cyq并创建用户cyq的home目录）
#+END_QUOTE

**** 设置密码
passwd命令。eg.

#+BEGIN_QUOTE
passwd cyq  (设置用户cyq的登陆密码)
#+END_QUOTE

**** 删除用户
userdel命令，带上-r参数，会联通该用户的home目录一起删除
**** 管理用户组
用户组的管理和用户管理基本一样，将user换成group就可以。
**** sudo和sudoers文件
使普通用户具有root的权限;给某个用户sudo权限，其实就是更改/etc/sudoers文件中的内容。sudoers文件中的，%开头指用户组。
 eg.
  - 禁止user用户组的用户添加用户：
       *%user ALL=(ALL) ALL,   !/usr/sbin/adduser,  !/usr/sbin/useradd*    
     ！表示禁止执行某些命令

  - root用户的权限
      *root   All=(ALL)     ALL*
     root用户可以使用sudo获得root权限
**** su
- sudo必须在每个命令前面都加上sudo，su命令可以直接切换为root用户，使用exit可以切换回原用户。
- 直接执行su不会改变当前的home目录，如果执行su - 就会切换到root的home目录。
- su还可以切换为任意用户，用法，su user（su user -，会连home目录一起切换）。
- sudo su -   使用这个命令可以让任何普通用户用自己的密码切换到root用户,  这是及其不安全的,  必须要在sudoers中禁止sudo的 su -权限

***** sudo su user - 的弊端
这个命令直接使用用户自己的密码切换成任意用户，这是及其不安全的，应该在/etc/sudoers文件中明确禁止su被sudo执行
**** whoami和who am i和who
***** UID和EUID
UID——实际用户，用户登陆时所使用的用户。实际用户是不会发生改变的。
EUID——有效用户，当前执行操作的用户。能够利用su和sudo进行任意的切换。
***** 他们的区别
whoami查看的是EUID，后两者查看的是UID。
** 文件和权限
*** 目录和文件
- 蓝色代表目录
- 绿色代表可执行文件
- 青色代表符号链接
具体配置取决于配置文件/etc/DIR_COLORS的规定
**** 开启颜色区分
- ls --color=auto
- 创建命令别名：alias ls='ls --color=auto‘
- 使设置永远生效：将alias命令添加到/etc/bashrc或/home/<user>/.bashrc文件中
*** 文件属性和权限
**** 文件属性行的分析
***** 三种权限
- r —— 可读，数值为4;
- w —— 可写，数值为2;
- x —— 可执行，数值为1;
***** 属性结构 
共分为7段：
*文件类型和权限 连接数 拥有者 所属用户组 文件大小 最后修改日期 文件名*
***** 文件权限组分析
共9个字母，分为三段，每3个为一段，分别为拥有者权限，所属用户组权限，其他用户权限。
**** 文件类型分析
- “-” 代表普通文件
- “d” 代表目录shad
- 

   0-- “l” 代表软连接和硬连接
- “b” 代表块设备文件
- “c” 代表字符设备文件
- “s” 代表套接字文件
- “p" 代表命名管道文件
*** 文件连接数
**** linux保存文件的方法
linux使用的文件系统是一种基于inode的文件系统（索引节点），是所有类unix的文件系统核心，每一个新创建的的文件都会被分配一个inode，并且每个文件都有一个唯一的inode编号，可以将inode理解为一个指针，指向的是文件所在的磁盘中的物理位置。所有的文件属性也都保存在inode中，系统是通过inode来定位每一个文件的，而不是通过文件名。为提高文件系统的执行效率，访问过的文件的inode会被缓存在内存中。 

连接数这个属性就是inode的引用计数，增加这个引用计数的元应在于：linux允许一个文件拥有多个名字。 文件名只是相当于对inode的一次引用。在使用ln命令建立文件链接的时候，会增加文件的连接数（即引用计数）
**** ln命令创建文件连接
***** 默认创建硬连接
*注意*
1. 硬连接的文件属性和目标文件完全相同，使用同一个inode，仅仅将inode的引用计数+1.
2. 硬连接要求必须与目标文件在同一分区中
***** ln -s xxx xxx  创建软连接（相当于快捷方式）
*注意*
软连接的文件属性和目标文件完全不同，软连接要占据一个新的inode，即软连接是一个新的文件
*** 修改文件的属性和权限
**** 修改文件所属用户组：
chown [-R] username filename
**** 修改文件的权限：
chmod命令
***** 文字法修改权限：
****** 四个字母：
- u：拥有者
- g：所属组
- o：其他用户
- a：所有用户
****** 三个操作符号：
- + 代表怎家权限
- - 代表去掉权限
- = 表设定权限
**** 深入文件权限
Linux的文件权限不止是r、w、x，还包括s和t两个特殊权限，它们与系统的帐号和系统的进程相关。
***** s标记（SUID）
- s这个标记出现在文件拥有者的x权限位上，称为Set UID，简称SUID，SUID权限的功能
  - SUID仅对二进制程序有效;
  - 执行者对于该程序具有x的可执行权限;
  - 执行者仅在执行该程序的过程中有效;
  - 执行者将具有该程序拥有者的权限（su具有SUID权限，该命令的拥有者是root，非root的执行者执行su时获得su的拥有者root用户的权限，即非root用户执行su后，获得了root用户的权限。 换句话说，具有SUID权限的命令，用户不需要使用sudo，直接执行，就能获得root权限的效果。
- s这个标记出现在文件所数组的x权限位上，成为Set GID，简称SGID
***** 设置SUID
使用u+s来设置SUID权限
***** t标记
出现在其他用户的x权限位上，t权限的名称是Sticky Bit，简称SBIT，仅对目录有效，作用如下:
- 用户对此目录拥有w和x权限
- 当用户在此目录下创建了文件或目录，仅自己和root才有权利删除该文件。 实例如下：用户U在目录D下创建了文件F，若D拥有SBIT权限，那么仅有用户U和root能删除文件F。SBIT应用的典型例子是/tmp目录，这个目录允许任何用户在里面创建文件，但是为了避免创建的文件被其他用户删除，把tmp目录设置为SBIT 权限，使得自己创建的文件仅能让自己或root删除。

** 文件的基本操作
*** 常用的文件管理命令：
- ls
- cd
- cp
- rm
- mv
*** 搜索文件
**** whereis
在数据库/var/lib/mlocate/中查询，这个数据库是linux系统自动创建的，包含本地所有文件的信息，并且每天通过自动执行updatedb命令更新一次。因为每天更新一次，所以whereis的搜索结果有时会不准确。

要获得准确的搜索结果，可以先手动执行updatedb。

*注意*
whereis只能搜索可执行文件、联机帮助文件和源代码文件，要获得更全面的搜索结果，可以使用locate命令。
**** locate 
和whereis命令类似，也是使用的相同的数据库
**** which
只搜索在$PATH环境变量中存在的路径。
**** find
*** 文件打包压缩
**** 解压缩tar包
tar -vxf filename
**** 压缩
tar -jcvf filename（j代表bz2压缩方式）
** 程序的执行问题
*** 执行程序的方法和多任务协调机制
直接在命令行输入程序名时，linux系统只会在$PATH环境变量所指定的那些路径中搜索对应的程序（windows会先搜索一下当前目录，在搜索$PATH所指定的目录），如果找不到就失败。如果要执行不在$PATH所指定的路径中的程序，必须使用相对路径或绝对路径，所以linux不能或忽略件的扩展名。
**** 管道
- 管道是linux系统提供的多任务协调机制的一种，应用十分广泛。
***** 管道的分类:
- 匿名管道（|）和命名管道（mkfifo）两种。
- 两种管道的共同特点：数据只能从管道的一端写入并从另一端读取，而且读出的顺序和写入的顺序是相同的。所以管道也叫做FIFO（First Input First Output）
***** 匿名管道和命名管道的区别：
匿名管道不记名，随叫随用，属于零时工;命名管道需要分配固定的资源，有固定的岗位和资源
***** 管道小结
管道链接多个命令，按照先后顺序，一个一个的执行。 

**** I/O重定向
- I/O重定向也是linux提供的一种多任务协调机制
- I/O重定向的概念：把输出给A的东西重定向给了B，或者反过来说将要从A处获得的输入重定向到B处去获得了。
***** I/O重定向的分类
- 隐式重定向：发生在“匿名管道”中
- 显式重定向（>）：显示的指明将命令输出的屏幕的内容重定向到磁盘文件中
**** 任务的前后台切换
***** 切换到后台
———————————
执行命令:     tail -f /etc/profile\\
按下ctrl+z\\
屏幕上输出[1]+  stopped  tail -f /etc/profile\\
然后执行命令：bg\\
屏幕上显示：[1]+ tail -f  /etc/profile &\\
这表明我们刚才创建的前台任务切换到后台了。  \\
———————————
- 如果想直接创建后台任务，可以直接在命令末尾添加“&”符号来完成
如：tail -f /etc/bashrc &
***** 查看后台程序
使用jobs命令，得到任务号。带+的是默认任务。
***** 后台切换到前台
使用fg命令，fg后跟上jobs得到的任务，直接执行fg是切换默认任务。
***** 结束前台程序
ctrl+c
***** 结束后台程序
- 使用kill命令：kill -9 %任务号，如kill -9 %2
- kill命令是传递信号给具体的任务或进程，-9就是一个信号，这个信号会强制干掉一个不正常的任务或进程。
- kill默认发出的信号实际上是-15，这个信号使得程序正常退出
- kill最后的那个参数实际上是传递一个数字的进程ID，但是这与任务号冲突，所以要加上%来加以区分。
*** 计划任务
**** 了解 cron 概念

cron 守护进程是一个由实用程序和配置文件组成的小型子系统，在几乎所有类 UNIX 系统上都可以找到某种风格的 cron。cron 的组件包括守护进程本身；一组系统范围的配置文件；一组针对特定用户的配置文件；一个用来添加、修改和删除用户配置文件的实用程序；以及一个简单的访问控制设施。一般来说，cron 配置文件或 cron 作业的列表被称为 crontab 或 cron 时间表。

守护进程 cron 连续运行，每分钟检查一次配置文件中的修改。cron 读取系统范围的和针对用户的 crontab（分别在下面两段中详细说明）、相应地更新事件调度计划并执行这一分钟内应该执行的所有命令。这个守护进程还捕捉每个作业的输出（如果有输出的话），并把结果通过电子邮件发送给作业的所有者。

可以在三个位置定义与系统相关的 作业：/etc/crontab、/etc/cron.d 中的任何文件以及特殊目录 /etc/cron.hourly、/etc/cron.daily、/etc/cron.weekly 和 /etc/cron.monthly：

主要的系统 crontab 是/etc/crontab。这个文件有独特的语法（在下一节中讨论），其中定义的每个作业根据它自己的时间表（比如每小时两次或每天一次）作为指定的用户运行。使用 /etc/crontab 调度各种管理和维护任务。

还可以在 /etc/cron.d 目录中维护一组 crontab。通过创建 crontab，按照逻辑对属于某一子系统的命令进行分组。例如，PHP 5 编程语言的包在 /etc/cron.d 中安装一个名为 php5 的 crontab，它会定期清除不使用的会话。/etc/cron.d 中的文件采用与 /etc/crontab 相同的语法，每个作业按照自己的时间表并作为特定的用户运行。

还可以把 shell 脚本直接放在 /etc/cron.hourly、/etc/cron.daily、/etc/cron.weekly 或 /etc/cron.monthly 目录中，这样就可以每小时、每天、每周或每月运行此脚本一次。
　　crontab 仅仅是一个文本文件，可以用任何 UNIX 编辑器编辑它。它可以包含四种代码行：空行、注释、环境变量设置和命令。

***** 空行和注释

文件中的空行和多余的空格被忽略。空行和空格有助于提高 crontab 的可读性，使 crontab 组织有序。还可以使用注释对每个作业的时间表和用途加以说明。要想创建注释，只需在一行的开头加上一个井号（#）。

***** 环境变量和命令

cron 最终使用一个 shell 执行每个命令。可以通过环境变量修改或定制 shell 的行为。在 crontab 中很容易设置 shell 环境变量。只需输入 VARIABLE=value，把 VARIABLE 替换为变量名，把 value 替换为一个值。例如，crontab 行：
*PATH=/usr/bin:/bin:/usr/local/bin*

指定一个有序的目录列表作为 shell 搜索路径。

cron 预定义了五个环境变量：
1. PATH 的默认值是 /usr/bin:/bin。
2. SHELL 预设置为 /bin/sh。
3. LOGNAME 初始化为 crontab 所有者的用户名。
4. HOME 设置为 crontab 所有者的主目录，比如 /home/joe。
5. MAILTO 设置为 crontab 所有者的名称。
6. 要想修改这些默认值或设置任何变量，只需在 crontab 中设置适当的环境变量。

当然，crontab 可以包含任意数量的命令行。每个命令行指定一个频率、一个用户名（只对于系统 crontab）和一个要运行的任务。例如，命令：
*5 0 * * *　 root　 find /tmp -type f -empty -delete*
在每天 12:05 a.m（5 0 * * *）删除 /tmp 中的所有空文件和目录（find /tmp -type f -empty -delete）。此作业作为根用户（root）运行。

系统 crontab 命令必须指定一个用户名，作为运行此任务所用的用户。（因此，在 /etc/crontab 中可能看到上面的命令）。针对用户的 crontab 不能指定用户名；一个用户的 cron 命令总是作为这个用户运行。是否有用户名是系统 crontab 和用户 crontab 之间的惟一差异。

**** 下面讨论定制时间表的众多方式。
***** 定制时间表

cron 时间表允许以多种方式运行作业，比如每分钟或在特定日期的特定时间。调度的参数非常灵活。

cron 字段
可以通过五个字段调整频率：分、小时、月中日、月份和周中的日期（如周一，周二）。表 1 总结如何调整每个字段。

　　表 1. cron 作业的调度选项

 
位置 	字段 	值 	说明
1 	分 	0-59 	 
2 	小时 	0-23 	 
3 	月中日 	1-31 	与分和小时不同，月中日不是从零开始的。
4 	月份 	1-12 	月份也不是从零开始的。也可以不使用 1-12 的数字，而是使用月份名的前三个字母，比如 jan 或 may。
5 	周中日 	0-7 	0 和 7 都代表星期日。还可以使用名称的前三个字母，比如 mon 或 wed。

除了名称或数字之外，还可以使用星号（*）表示 “所有”。例如，在分钟位置上的星号表示这一天中的每一分钟。（在某些情况下确实需要如此高的频率，但是一定要小心，以这种频率执行的任务应该非常简单，不会长时间运行）。

还可以使用值的列表、范围和步长（增量）分别指定多个值、连续的值范围和不连续的值范围。甚至可以组合使用列表和范围。列表 是一个逗号分隔的值集。范围 由启始值和结束值（含）以及可选的步长值构成。

我们来看一些示例。表 2 中的每一行包含一个时间表及其说明。当分、小时和日期字段与当前时间匹配时，cron 会执行命令；如果月中日和周中日受到限制（也就是说，不是 *），那么当这两个字段中至少一个 与当前时间匹配时，cron 也会执行命令。

表 2. cron 作业的时间表示例

调度计划 	 
分 	小时 	月中日 	月份 	周中日期 	说明
0 	1 	15 	1,  3,  5,  7,  9,  11 	* 	在 1、3、5、7、9 和 11 月的 15 日的 1 a.m. 运行命令。为了更容易理解，也可以把这个时间表写成 0 1 15 jan,  mar,  may,  jul,  sep,  nov *。在指定列表时，不要在逗号后面加空格。
0-59/15 	* 	* 	* 	* 	这个调度计划每 15 分钟运行命令一次。
30 	* 	* 	* 	wed,  fri 	这个时间表只在星期三和星期五每小时的 30 分时执行命令一次。（在列表中可以使用日和月份的名称，但是在范围中不可以）。
0,  30 	0-5,  17-23 	* 	* 	* 	在午夜到 5 a.m. 以及 7 p.m. 到 11 p.m. 之间整点时和 30 分时运行命令。
0 	0 	1 	1 	* 	在每年 1 月 1 日午夜执行命令一次。
0 	0 	* 	* 	0 	在每个星期日午夜运行命令。这相当于每周一次。
30 	0 	10,  20,  30 	* 	6 	因为月中日和周中日受到限制，这个时间表在每星期六和每月的 10、20 和 30 日（二月除外）的 12:30 a.m. 运行命令。

如您所见，实际上可以使用这五个参数指定任何调度计划。为了更加简便，Vixie cron 还提供了常用调度计划的简写形式。表 3 列出一些简写形式。

表 3. 常用调度计划的简写形式

简写形式 	说明
@reboot 	每当计算机重新引导时运行命令。
@daily 	每天一次的简写形式。
@weekly 	每周一次的简写形式。
@annually 	每年一次的简写形式。也可以写成 @yearly。
@midnight 	在每天午夜运行命令。这个简写形式相当于 @daily。

如果喜欢使用简写形式，只需用它们替代 cron 命令的前五个字段。下面这个命令看起来简单多了。

@daily root /usr/local/scripts/clean_old_files.sh

**** crontab 命令示例

掌握了基本概念之后，我们来看一些用户 crontab 命令示例。同样的命令也可以应用系统范围：只需在所有系统 crontab 项中周中日字段（第五个字段）后面指定一个用户名。

***** 创建个人 crontab

　　要想创建个人 crontab，可以用任何文本编辑器创建一个文件。按照惯例，个人 crontab 文件保存在 ~/.crontab 中，但是可以使用任何文件名。

PATH=/usr/bin:/bin:/usr/local/bin
#
# Every day,   print and delete all temporary files whose names begin with '.#'
@daily　　　find $HOME -type f -name '.#*' -print -delete
　　
#
# Every week,   show me what is consuming space in my home directory
@weekly　　 du -sh $HOME

　　通过 crontab 实用程序提交个人 crontab

　　在编辑文件（比如 ~/mycrontab）之后，通过 crontab 实用程序把它提交给 cron：

% crontab ~/mycrontab

　　查看 cron 中存储的信息

　　要想查看 cron 中存储的信息，可以输入 crontab -l：

% crontab -l
PATH=/usr/bin:/bin:/usr/local/bin
　　
#
# Every day,   print and delete all temporary files whose names begin with '.#'
@daily　　　find $HOME -type f -name '.#*' -print -delete
#
# Every week,   show me what is consuming space in my home directory
@weekly　　 du -sh $HOME

　　替换 crontab

　　在任何时候，都可以使用 crontab 实用程序替换您的 crontab。只需提交一个新文件或同一文件的修订版。要想删除 crontab 作业，只需输入 crontab -r：

% whoami
joe
% crontab ~/mycrontab
% crontab -l
PATH=/usr/bin:/bin:/usr/local/bin
...
% crontab -r
% crontab -l
crontab: no crontab for joe

　　替代 cron 的机制

　　尽管 cron 确实很有用，但是您还应该了解可以替代它的两种机制。

　　anacron

　　如果系统常常关机或进入休眠状态（例如，如果使用 UNIX 笔记本计算机的话），那么可以考虑在系统中添加 anacron。anacron 与 cron 的相似之处在于，它也把作业安排在以后运行；但是，与 cron 不同，即使作业的预定运行时间已经过了，anacron 也会运行作业。

　　例如，如果安排在星期六运行文件系统备份，但是系统在星期五到星期一关机了，那么当系统在星期一重新启动时，anacron 会立即运行星期六的作业。与之相反，cron 仅仅检查现在是否应该运行作业；因此，如果在作业的预定运行时间系统是关闭的，就不运行作业。

　　anacron 的调度选项比 cron 少得多。它只能以整天的时间间隔调度作业，比如一天、7 天或 30 天；但是对于那些必须频繁且可靠地运行的作业，它是更好的选择。

　　另外，必须从 cron 启动 anacron。每当 anacron 运行时，它读取自己的配置文件。配置文件包含由作业及其频率（用天数表示）组成的配置对。如果作业在预定的时间没有运行，anacron 就运行此作业并记录运行作业的时间。运行完所有作业之后，anacron 退出。

　　在大多数 Linux 发行版上都可以找到 anacron，但是也很容易自己下载并构建源代码。访问 anacron 项目页面 获得最新版本。

　　anacron 的主要配置文件可以在 /etc/anacron 中找到。可以像配置 cron 时那样设置环境变量，但是更简单：

SHELL=/bin/zsh
PATH=/usr/bin:/bin:/usr/local/bin
# format: frequency delay name job
1 10 day-to-day daily.chores.sh

　　第一个数字是周期，所以 1 表示每天运行一次，7 表示每 7 天运行一次，等等。第二个数字是延迟，也就是从 anacron 启动之后到执行这个作业之间等待的分钟数。如果把延迟字段设置为不同的值，就可以防止所有作业同时启动。名称 day-to-day 只是一个有帮助的昵称。配置行的其余部分指定作业；在这里，每天运行在指定路径中找到的 shell 脚本 daily.chores.sh 一次。

　　anacron 以手册页形式提供了出色的文档，还可以在网上找到关于 anacron 的提示。（请阅读我在 2007 年 10 月编辑的 Rod Smith 撰写的 Linux Magazine 文章）。anacron 适合 UNIX 爱好者和需要额外保障的系统管理员使用。

　　launchd：cron 的现代替代机制

　　cron 确实是一种功能强大、值得信赖的实用程序，它的广泛流行就证明了这一点。Vixie cron 最近又有所改进，比如增加了简写方式 @reboot，进一步简化了管理。但是，cron 仍然有一些缺点：

　　尽管可以在 crontab 文件中定义 cron 作业，但是不能从命令行启动和停止 cron 作业。另外，不能在命令行上创建专用作业并提交给日历。

　　cron 不实施资源限制。如果作业作为根用户运行，就能够消耗无数的处理器时间和内存。在实践中，可能希望限制一个作业，以免它影响其他 cron 作业和系统操作的总体质量。

　　cron 作业严格地与一个调度计划相关联。例如，无法只在发生某一事件（比如创建一个文件）时启动作业。

　　从更大的范畴来看，类 UNIX 系统的许多核心组件都能够根据需要启动其他程序，包括 cron、用于网络守护进程的 xinetd（或 inetd）和 init（所有系统进程的起源）。每个核心组件都有自己的配置文件，所以很难知道哪个组件最适合完成某个修改。

　　为了克服这些缺点，Apple Computer 开发了一个统一的启动工具 launchd，它可以在引导时、根据需要和按照指定的时间间隔启动进程。实际上，在 Mac OS 10.4 Tiger 中 launchd 已经替代了 cron（和 init 以及用来引导和初始化系统的其他几个系统实用程序）。（Apple 在系统上保留了 cron，以便为用户提供方便，而且 Vixie cron 的调度选项更灵活）。Mac OS X 的引导速度很快确实可以归功于 launchd：它会在引导时列出要启动的程序，但是只在首次需要时执行程序。

　　launchd 是开放源码的，可以从 Mac OS Forge 上它的主页获得源代码。目前，launchd 已经被移植到 FreeBSD 上，但是还没有移植到其他 UNIX 或 Linux 系统。但是，许多项目正在积极地实现与 launchd 等效的程序，所以简要地了解它的特性是有必要的：

　　launchd 并不创建作业来检查目录中是否有新文件，而是自动监视目录中是否有新文件或者监视空目录中是否添加了任何文件，并根据需要启动作业。launchd 不执行轮询；而是使用 kqueues 设施让内核在目录发生变化时通知它。（Linux 具有一种相似的事件设施 inotify，以后的一篇 developerWorks 文章将讨论它） 。

　　如果指定了，launchd 会使用 chroot 把您的作业发送到一个新目录。chroot 读作 “cha-root”，它是一个系统调用，可以改变前向斜杠（/）和根目录指向的目录。因此，如果使用 chroot 把文件发送到 /opt/root，/opt/root 之外的所有文件就是不可访问的（毕竟，/opt/root 现在是 /，也就是文件系统的顶级目录），/opt/root 中的所有目录成为一级目录。通常使用 chroot 限制作业，使代码无法进入更大的文件系统，以避免产生损害。

　　可以为作业设置资源限制。可以限制的资源包括内存、堆栈大小和打开的文件的最大数量。

　　当定义一个任务并把它装载到 launchd 中之后，可以按照名称从命令行启动和停止作业。

　　launchd 由三个组件组成：launchd 守护进程本身；用来添加、修改和删除作业以及控制 launchd 的 launchctl 实用程序；一个或多个配置文件，每个文件定义一个或多个作业。由于它起源于 Mac OS X，launchd 配置文件只是简单的属性文件，可以用 Extensible Markup Language (XML) 表示。

　　简单地说，在 Mac OS X 上使用 launchd 的步骤如下（要监视一个目录中添加的文件并根据需要运行作业）：

　　创建一个属性文件来表达此作业及其所有属性。

　　可以使用 Mac 的 Property Editor，也可以手工编辑 XML。无论采用哪种方法，产生的文件都应该与 清单 1 相似。

　　清单 1. 监视文件系统目录变化的 launchd 作业示例

<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple Computer//DTD PLIST
　　　　　　1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
　　<key>Label</key>
　　<string>com.example.processor</string>
　　<key>OnDemand</key>
　　<true/>
　　<key>Program</key>
　　<string>/Users/strike/bin/processor</string>
　　<key>ProgramArguments</key>
　　<array>
　　　　<string>processor</string>
　　</array>
　　<key>WatchPaths</key>
　　<array>
　　　　<string>/Users/strike/data/incoming</string>
　　</array>
</dict>
</plist>

　　简单地说，当 /Users/strike/data/incoming 目录的内容发生变化时，此文件运行 /Users/strike/bin/processor 中的实用程序脚本。把 OnDemand 设置为 True 让 launchd 根据需要启动此作业。把此文件保存到 ~/Library/LaunchAgents/com.example.processor.plist。

　　用 launchctl 把此作业装载到 launchd 中：% launchctl load ~/Library/LaunchAgents/com.example.processor.plist

　　如果希望检查最近的操作或查看保存的作业的列表，只需输入 launchctl list。

　　要想删除作业，只需带 unload 选项使用 launchctl：% launchctl unload -w ~/Library/LaunchAgents/com.example.processor.plist

　　-w 的作用是什么？它完全删除 launchd 中的作业。如果没有这个选项，作业会在登录时自动地重新装载（因为作业还在启动代理的用户集合中）。

　　launchd 手册页包含大量信息；如果您是 Mac OS X 用户，还可以找到大量针对 launchd 的应用程序。一些聪明的开发人员正在把 launchd 迁移到更广泛的平台。

　　使用 cron 让工作更轻松

　　学习关于使用 cron 的一些提示和技巧，了解这个守护进程和相似的其他程序为什么是您的好朋友。

　　提示和技巧

　　下面是关于 cron 的一些提示、技巧和常见的问题：

　　与在终端窗口中使用的 shell 或 shell 脚本不同，cron 并不 在 crontab 文件中就地展开环境变量。换句话说，如果在 crontab 中输入：HOME=/home/joe
PATH=$HOME/bin:/usr/bin:/bin

　　那么 PATH 并不会设置为您期望的路径。您必须手工展开所有变量，比如：

HOME=/home/joe
PATH=/home/joe/bin:/usr/bin:/bin

　　但是，因为每个 cron 命令都由 shell 执行，所以命令可以 引用变量名。例如，如果在个人 crontab 中编写以下命令（注意这一行中省略了用户名参数）：

@daily　$HOME/bin/cleanup_daily.sh

　　那么 $HOME 会正确地展开。

　　不要把计算密集型任务安排在同一时间启动，比如 @midnight。如果可能的话，在凌晨的几小时中分散地启动这些任务，以避免它们争用资源。

　　正如上面提到的，在默认情况下环境变量 SHELL 设置为 /bin/sh。如果不修改此变量，crontab 中的所有命令都由 /bin/sh 解释。但是，如果您不熟悉 /bin/sh，更喜欢另一种 shell，那么可以设置 SHELL 并使用这种 shell 的命令语法。

　　例如，如果设置 SHELL=/bin/zsh，那么所有命令都可以使用 Z shell 的功能，比如它的高级重定向操作符：

SHELL=/bin/zsh
@daily　uptime > daily >> weekly

　　在这里，uptime 命令的输出覆盖 daily 文件（>daily）并追加到 weekly 文件中（>> weekly）。

　　使用访问控制列表 (ACL) — /etc/cron.allow 和 /etc/cron.deny — 允许或拒绝特定用户运行 cron 作业。如果希望把对 cron 的访问权限制在很少几个用户，那么在 /etc/cron.allow 中列出这些用户的用户名。未指定的任何用户都无法使用 crontab 实用程序提交 crontab。但是，如果希望允许大多数人访问 cron 而拒绝少数用户，那么在 /etc/cron.deny 中列出受到限制的用户。

　　例如，如果 /etc/cron.allow 的内容如下：

joe
zelda

　　那么除 Joe 和 Zelda 之外任何用户都无法访问 cron：

% whoami
strike
% crontab ~/.crontab
You (strike) are not allowed to use this program (crontab)
See crontab(1) for more information

　　要想禁用 cron 发出的电子邮件报告，应该在 crontab 中设置 MAILTO=""。

　　再次重申，不要在列表中使用空格。列表值以逗号分隔。在 Vixie cron 中，在范围中不使用日和月份的名称。

　　要仔细阅读系统的 cron 文档。路径、特性和简便措施都可能不一样。在命令行上输入 man 5 crontab 了解 crontab 文件的语法。输入 man 1 crontab 了解 crontab 实用程序。在命令行上输入 man cron 或 man 8 cron 了解 cron 守护进程本身的选项。

　　系统管理员最好的朋友

　　cron 和与它相似的程序对于系统管理员非常有帮助。如果您需要反复执行相同任务，就可以考虑用 cron 实现自动化。捕捉具有许多步骤的复杂任务常常需要 shell 脚本，但是许多任务只需要一行命令。

　　下面仅仅是一些思路：

　　通过组合使用 cron 和数据库工具，创建每日转储。例如，命令：@daily joe mysqldump -pjoespwd accounts > $HOME/backups/accounts.`date +%F`.sql

　　每天把数据库 accounts 转储到一个文件。嵌入的日期命令（`date +%F`）确保文件名是惟一的，比如 accounts.2008-08-07.sql。此命令作为用户 joe 运行，所以用 -p 指定 Joe 的密码。此命令还可以放在 Joe 自己的 crontab 中，因为转储需要他的 MySQL 凭证。

　　locate 子系统为系统上的所有文件编制索引，并把每个文件的完整路径存储在数据库中。然后，从命令行查询此数据库，就可以立即找到文件。当然，可以根据需要用 find 搜索文件，但是必须等待它搜索文件系统，这可能很慢。

　　为了让定位子系统发挥作用，必须定期为文件系统编制索引，因为随时可能添加和删除文件。这种情况就非常适合使用 cron。

0 0,  12 * * * root updatedb

　　这个 crontab 项每天运行 updatedb（locate 更新实用程序）两次。

　　显然很适合用 cron 实现自动化的另一个任务是，把文件从主服务器复制到众多的从服务器。rsync 是一种跨多个系统分布和同步文件集合的现代实用程序。许多网管都通过组合使用 cron 和 rsync 把网站的主拷贝复制到服务器群中的每台服务器。@midnight www rsync -avz /var/www/site slave1:/var/www

　　在每天午夜，rsync 都会把 /var/www/site 复制（-avz）到 slave1 上的 /var/www。

　　使用命令行实用程序 mail 和 shell 管道操作符（|）把任务的输出发送给团队中的一个或多个成员。

@weekly root df --print-type --local -h |& mail -s "Weekly df report" andy bob

　　在这里，每周通过电子邮件把 df 的输出发送给用户 Andy 和 Bob，让他们能够监视磁盘使用量。

　　结束语

　　教程结束语

　　无论您是单独使用 UNIX 系统，还是管理有数百位用户的系统，自动执行维护任务都有助于节省时间、减少错误以及保持机器不间断运行。cron 是在 UNIX 系统上实现自动化的关键组件，只需发挥一点儿想像力，就可以让计算机为您工作，而不是由您 “伺候” 计算机。
　　cron 有助于更轻松地完成工作。现在，您可以睡个好觉了。
**** 计划任务的分类
- 一次性
- 周期性
**** 一次性计划任务
- 使用at命令，每次执行at命令需要给他一个时间参数，如：at 10：00 tomorrow，这条命令要求明天早上10点整执行一个程序。
- 执行at命令后，命令行会变成： at > ，此时，只要直接输入想要执行的命令即可。输入玩命令后，按组合键ctrl+D来保存。然后就会立即显示类似这样的内容：
job 1 at 2016-3-12 10：00
**** 周期性任务（cron）
- 铜鼓crontab命令来完成，crontab -e 编辑当前用户的cron表
***** cron任务的完整定义
*分钟 小时 日 月 周 [用户名] 命令*
***** cron时间符号
| 符号 | 含义                                                 |
|------+------------------------------------------------------|
| *    | 代表任意时间                                         |
| ，   | 代表分隔出不连续的时间点，比如2，3，表示2点和3点都行 |
| -    | 代表连续的时间段，比如2-4表示2、3、4                 |
| */n  | 表示每隔单位时间                                     |
|      |                                                      |
*** 守护进程及其作用（daemons）
**** 守护进程的分类
- 独立启动的stand alone
自行启动，不需要利用系统其他机制来管理，启动只后会一直占用系统哦嗯资源和内存。\\

有一个最突出的优点：响应最快。

stand alone守护进程非常多，如常见的apache、mysql等。
- xinetd
新型的守护进程，由一个统一的stand alone守护进程来负责唤起，这个特殊的守护进程叫super daemon。

这是一种按需分配的进程服务，只有当客户端有要求时，super daemon才会去唤醒具体的xinetd守护进程

缺点：不能及时响应。\\
优点：赋予super daemon安全管控的机制，类似防火墙功能
**** stand alone守护进程的启动脚本的目录
/etc/init.d/目录下  
***** stand alone守护进程的常用命令选项：
- start
- stop
- restart
**** xinetd守护进程的配置文件
- /etc/xinetd.d目录下和/etc/xinetd.conf文件中。一般不用关心xinetd.conf文件的内容。/etc/xinetd.d中的每个文件代表一个独立的xinetd守护进程。
*** 全面了解程序信息
**** ps命令（截取某个时间点的程序状态，是静态数据）
*ps命令的三种常见用法*
1. ps aux 查看系统中所有程序的数据;
2. ps ux  查看当前用户所有程序的数据;
3. ps -l  查看与当前终端关联的程序数据;
***** ps -l命令输出的各个字段的说明
- F:程序标志，代表程序的执行权限，常见取值有：0（普通权限）;4（root
权限）;1（此程序仅执行了fork而没有执行exec。
- S：代表程序状态,  R:运行中;S：睡眠状态，可唤醒;D：不可被唤醒状态，一般实在等待I/O;T：停止状态，比如被调试的时候;Z：僵尸状态，程序已经终止，但是却无法把它移出内存。
- UID：代表词进程拥有者的UID。
- PID：代表此进程的进程ID。
- PPID：此进程的父进程ID。
- C：cpu的使用率，单位为百分比。
- PRI：运行优先级。
- NI：运行优先级调整。
- ADDR：指出该程序在内存的哪个部分，如果是个running程序，一般显示“-”。
- SZ：此程序用掉的内存。
- WCHAN：表示目前程序是否运行中，若为“-”表示正在运行。
- TTY：登录者的终端机位置。
- TIME：使用掉的cpu时间，不是系统时间。
- CMD：这个代表程序名称，这里的cmd是command命令终端程序。
**** top（每5秒刷新一次的系统负载）
**** pstree 查看进程的父子祖先关系
** 软件的安装
*** 从源码安装
因为不确定源码中是否包含上次编译过的目标文件（(*.o），最好先用make clean 或make distclean去除目标文件，以保证新编译出来的可执行文件是在自己的机器上编译完成的。
- 第一步：configure（生成makefile文件)
- 第二步：make
- 第三步：make install

源码安装的缺点：没有做软件相关性检查，会导致它依赖的其他软件不存在或者版本不准确，从而有可能无法正常运行。
*** 利用软件管理工具rpm和dpkg
|      | RPM                                                            | DPKG                                                              |
|------+----------------------------------------------------------------+-------------------------------------------------------------------|
|      | red hat包管理器                                                | debian软件包管理器                                                |
| 安装 | rpm -ivh <软件包名>                                            | dpkg -i <软件包名>                                                |
| 查询 | rpm -qa ×××*;查找此软件像系统写入的文件：rpm -ql <软件包名> | dpkg -l ×××*;查询系统中属于xxx软件的文件：dpkg --listfiles xxx |
| 卸载 | rpm -e <软件名>                                                | dpkg -e <软件名>                                                     |
*** 在线安装机制
- dpkg管理机制的apt在线安装/升级
- rpm的yum/you/urpm等在线安装/升级
**** apt/yum等在线安装机制的意义
- dpkg/rpm等的弊端：没有完全解决软件属性相依的问题，无法避免软件包的依赖问题。
- apt/yum等的优势：获取软件包的依赖，通过网络自动的下载安装，从而解决软件包的依赖问题。
**** 操作
|      | yum                                                                                                                                                                     | apt                                                                                                                                                              |
|      |                                                                                                                                                                         |                                                                                                                                                                  |
|------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 安装 | yum install package_name                                                                                                                                                | apt-get install package                                                                                                                                          |
| 升级 | yun update package                                                                                                                                                      | apt-get update（刷新软件源，建立跟新软件列表）;apt-get upgrade（一次性升级所有软件包）                                                                           |
| 卸载 | yun remove package                                                                                                                                                      | apt-get remove package; apt-get purge remove package（清除软件包的同时清除配置，彻底删除）                                                                       |
| 查询 | 1. yun search keyword（查询软件包） 2. yum list installed（列出已经安装的软件包） 3. yum info package（获取软件包信息） 4. yum provides package（列出软件包提供的文件） | 1. apt-cache search keyword（查找软件包） 2. apt-cache show package（获取制定软件包的详细信息） 3. apt-cache showpkg package（获取软件包版本和软件包的依赖关系） |
| 清除缓存 | yum clean headers（清除header）;yum clean package（清除下载的rpm包）; yum clean all（清除缓存的软件包和旧的headers）                                                    | apt-get clean（清除整个软件包缓冲区）; apt-get autocelan（按照依赖关系清理缓冲区中多余的软件包）                                                                                                 |
** 磁盘的管理方式
*** linux的文件系统
ExtN（N=2、3、4）
*** 磁盘的基本操作
最常用的：df、du、dd、fsck、mountdf：
**** df
查看系统中所有磁盘的整体使用量;
**** du
查看目录的容量，执行效率比df差很多;
**** dd
把一个目录完整copy到另一个目录，可以制作系统u盘镜像。
***** 用法：
dd if=input_file of=out_file

if和out这两个参数可以不用给定，有默认值。if的默认值是标准输入，of的默认值是标准输出（相当于cat命令，即在屏幕上显示文件）

通过bs和count这两个参数，能够指定读写的字节数和读写次数
***** dd应用举例 
dd1. dd if=/etc/bashrc  —— 缺省of，作用是把/etc/bashrc文件的内容在屏幕上显示。
2. dd if=/dev/sda1 of=./sda1.img  —— 制作磁盘1第一个分区的镜像文件。
3. dd if=/dev/sda1 |gzip -9 > ./sda1.img —— 备份sda1,  并压缩，然后写入镜像。
4. dd if=/dev/sda | gzip -9 > ./sda.img ——备份整个磁盘
5. gzip -dc ./sda.img |dd of=/dev/sda —— 恢复磁盘
6. dd if=/dev/sda of=./mbr.img bs=512 count=1 —— 备份磁盘的住引导记录（磁盘的前512个字节，就是第一个扇区的内容，也就是启动扇区。
**** fsck（修复文件系统）
很少手工执行，基本上在系统启动阶段自动执行。使用方式：fsck -t 文件系统 设备名\\
比如：fsck -f -t ext3 /dev/sda3 (f参数表示强制检查，否则，在没有报错的系统中是不会检测的。）
**** mount（挂载）
用法：mount [-t 文件系统] 设备名称 挂载点
*注意*
对于挂载windows目录，文件系统参数不能省略。挂载extn目录，文件系统参数可以省略。

*eg.*
mount -t vfat /dev/sdb1 /data
mount -o loop /xxx.iso/ /mnt/xxx/   （挂在光盘镜像）
**** umount（卸载）
*用法*
umount /目录
**** fdisk（磁盘分区）
**** mkfs.*（格式化）
*取决于格式化成什么系统，比如要格式化为ext3，就应该是mkfs.ext3
*** /etc/fstab文件 —— 决定分区的连接
让各个磁盘的各个分区具体挂载到哪个目录是由/etc/fstab文件所决定的，所以这个文件非常重要，一旦损坏或丢失，系统将无法正常启动。
**** 创建交换分区swap
- fdisk 创建交换分区
- mkswap 格式化
**** 挂载swap分区
- swapon 挂载swap
- swapoff 卸载交换分区
**** 普通文件成为交换分区
eg. 创建一个1G的交换文件：\\
dd if=/dev/zero of=/tmp/swap bs=1M count=1024 \\ 
(/dev/zero 是个空文件，这个dd命令的作用就是创建一个1G的空文件）
mkswap /tmp/swap\\
*** 逻辑卷
**** 什么是逻辑卷
***** 更换分区目录（如更换home目录分区）
- 划分更大的分区格式化为linux系统;
- 将原/home目录下的内容全部复制到新的分区;
- 修改/etc/fstab文件，让新的分区成为/home;
***** 逻辑卷的概念
能够弹性的调整文件系统的容量。理论上说，逻辑卷就是在磁盘分区和文件系统之间增加了一个逻辑层，当文件系统容量不够用时，可以向逻辑卷中增加新的分区来实现扩大容量的目的;而当发现文件系统过大而有磁盘浪费的时候，可以选择去除一些基本没有使用的磁盘分区来达到减少容量的目的。

在linux系统中，实现逻辑卷功能的是LVM，Logical Volume Manager，逻辑卷管理器
**** 基本属于和原理
***** Physical Volume，PV，物理卷
物理卷就是具体的磁盘分区，或者与磁盘分区有相同功能的设备，比如RAID。

PV是LVM的基本存储单元，与普通的磁盘分区相比，PV（物理卷）还要包含与LVM相关的管理参数
***** Volume Group，VG，卷组
卷组类似于非LVM系统中的物理磁盘，由多个物理卷组成，可以在卷组上创建一个或多个LVM分区
***** Physical Extend，PE，物理扩展区
每一个物理卷被进一步划分为被称为物理扩展区的基本单元，PE是LVM的最小存储区，与物理磁盘中的扇区或文件系统中的簇的概念基本相同。LVM的默认PE大小是4M，每个卷组最多仅能含有65534个PE。所以，一个卷组的最大容量就是4×65534=256G
***** Logical Volume，LV，逻辑卷
逻辑卷就是在卷组的基础上再进行切分，与在物理磁盘上继续划分分区是一样的道理，逻辑卷的大小必须是PE的整数倍。

需要增加容量，就增加PE，需要减少容量，就减少PE。这就是LVM能够弹性的调整容量的秘密。
**** 扩大和减小逻辑卷
*后续在研究*
** linux下的网络基础
*** 了解ip地址
（待记录……）
*** 相关配置文件
（
** sh相关知识
shell是命令行解释和执行器，是介于使用者和unix/linux操作系统核心程序（kernel）之间的一个接口。
*** bash
bash（bourne again shell）是linux下的经典shell，对bourne shell 做了向下兼容，融入了许多C shell和Korn shell的功能
**** bash的特点：
- 别名功能（alias）。
- 历史命令（history），默认显示500个历史命令。
- 工作控制（job control）

下面个几个命令控制进程的进行：

 + ps —— 列出正在运行的进程
 + kill —— 向一个或多个进程发信号（杀掉进程）
 + jobs —— 列出自己运行的进程
 + bg —— 将进程放到后台
 + fg —— 将进程放到前台
*** 环境变量
- 登陆系统后，shell启动，并从启动它的/bin/login程序中继承了多个变量、I/O流和进程特征。如果遇到需要后台处、执行整组命令及脚本的情况，父shell会派生子shell应付这些工作，子shell从父shell那里继承环境。这个环境包括进程的权限、工作目录、文件创建掩码、特殊变量、打开的文件和信号。

- 变量包括局部变量和环境变量，局部变量无法传递给子shell，环境变量可以一直传递下去。

- 环境变量包括：PATH、HOME、LOGNAME、IFS和SHELL. 环境变量一般大写

- 环境变量的设定：set、env、export

- 环境变量的清除：unset
*** bash的配置文件
- login shell：输入登陆用户名和密码后shell才启动。

- non-longin-shell：不需要做重复的登陆操作获取bash界面。
**** 系统配置文件
只有login shell才会读取系统配置文件/etc/profile，每个用户登陆bash后都会读取这个配置文件，如果想要设置的环境变量对所有的用户起作用，就要在这里设置
**** 用户个性配置文件
- login shell 读完了/etc/profile配置文件后，就会读取用户的个人配置文件，个人配置文件主要有三个home目录下的隐藏文件：
  1. ~/.bash_profile
  2. ~/.bash_login
  3. ~/.profile

- 如果1存在，那么bash不会读取2、3，如果1不存在，bash会读取2，如果1和2都不存在，那么bash会读取3。

- ~/.bashrc ： 如果这个文件存在，那么~/bash_profile还会调用它，哦哦们可以把一些环境设置写到该文件下。

- ~/.bash_history和~/.bash_logout
  - bash_history 保存命立的历史记录，每次登陆bash后，bash会读取这个文件，将所有的历史命令读入内存。
  - bash_logout 告诉系统在离开系统之前需要做的事情。默认情况下，文件只让bash清掉屏幕的信息。用户可以添加信息在这个文件中，例如备份等。
**** non-login shell的设置
详见p100
** 文本处理
*** 查看文本内容
查看文件的命令：
- cat
- more
- less
- head
- tail：tail可以实现不停的读取和显示文件内容，可以用于查看日志起到实时监控的作用。
*** 正则表达式
**** 正则表达式的基本要素：
- 表达式ε表示一个文本，包含一个长度为0的字符串，可以理解为{NULL}。通常将NULL记做ε。
- 表达式a表示仅有一个字符a的文本，即{a}
**** 正则表达式的三种基本运算规则：
- 并运算，记做X|Y，a|b={a，b}，相当于加法;
- 连接运算，记做XY，ab={ab}，X=a|b，Y=c|d，XY={ac，bc，ad，bd}，相当与乘法;
- 正则表达式的克林毕包，记做X* ,   表示将n个X与自己相连接，然后在就并，即X*=ε|X|XX|XXX|XXXX|……，a*={ε,  a,  aa,  aaa,  aaaa,  …………………}是一个无穷文本。
**** 运算的优先级
克林毕包>连接>并
**** 正则表达式的扩展运算
- [] 表示括号内的字符做并运算，同时支持范围描述符号“-”。[abcd]=a|b|c|d=[a-d]
- 普通字符“-”在[]中的描述。应为在[]中支持范围描述符“-”，如果要在[]使用字符“-”，需要将它放在[]中的开头或最后，如[-abc]=-|a|b|c,  [abc-]=a|b|c|-;
- []中以^开头，表示在字符集中排


除[]中的所有字符之后，所剩下字符的并运算，[^ab]表示对除了ab以外的所有字符求并。
- X？表示X|ε，代表X与空字符之间可选。
- X+表示XX*，这表示X至少要重复一次，即至少等于X
*** grep搜索文本
包含grep、egrep、fgrep。

egrep是grep的扩展支持跟多的正则表达式元字符

fgrep就是fixed grep或fast grep，只搜索字符，不使用正则表达式

gnu版的grep可以通过 -G、-E、-F命令选项来选择
**** grep支持的正则表达式
| 元字符   | 匹配对象                                                                                      |
|----------+-----------------------------------------------------------------------------------------------|
| ^        | 表示句首。如^abc表示以abc开头的句子                                                           |
| $        | 表示句尾。如abc$表示以abc结尾的句子                                                           |
| *        | 表示前一个字符0个或多个重复存在，如ab*c表示a和c之间有0个或多个b                               |
| []       | 匹配指定范围内的字符，如^[0-9]表示以数字开始的行                                              |
| [^]      | 匹配一个不在指定范围内的行，如[^（D-F）level]表示匹配不包含D-F的一个字符开头的并紧跟level的行 |
| （……） | 匹配一个不在指定范围内的字符。例子同上                                                        |
| \<       | 表示词首。如\<abc表示以abc开头的词                                                            |
| \>       | 表示词尾。如abc\>表示以abc结尾的词                                                            |
* 第三章 一棵“树”的奥秘
** linux的文件组织结构（p109 图3.1）
** 基本组织原则（p110）
** 根文件系统
*** 原则与特性
根文件系统保存在根分区，负责系统启动、修复、更新、恢复等重要任务
*** 必备内容
| 名称  | 功能                        |
|-------+-----------------------------|
| bin   | 重要的可执行文件，shell命令 |
| boot  | 引导器配置文件、内核        |
| dev   | 设备文件                    |
| etc   | 系统专有配置文件            |
| lib   | 重要的共享库和内核模块      |
| media | 可移动设备挂载点            |
| mnt   | 其它文件的临时挂载点        |
| opt   | 附加应用软件包              |
| sbin  | 重要的必须的系统可执行文件     |
| srv   | 本系统提供的用于服务器的数据 |
| tmp   | 临时文件                     |
| usr   | 文件系统的第二层             |
| var   | 可变数据                         |
** 子目录
*** /etc目录
 包含系统特有的配置文件
**** 需要放在/etc目录下的文件
| 名称 | 功能               |
|------+--------------------|
| opt  | 各软件的配置文件   |
| rc.d | init进程的配置文件 |
| X11  | X window系统的配置文件，可选 |
| sgml | sgml的配置文件，可选         |
| xml  | xml的配置文件，可选                  |

- X11目录下的文件：\\
  - xorg.conf —— Xorg的配置文件（最常见）
  - Xmodmap —— 定义xdm和xinit所使用的键盘映射
  - xconfig —— 早期的XFree86的配置文件（现在已经被xorg取代）
*** /sbin目录——必备的系统软件
用于系统维护的软件和某些只限root用户使用的命令存储在/sbin、/usr/sbin和/usr/local/sbin目录下。
- /sbin目录存储的是那些在系统启动、恢复、欢迎以及修复过程中必备的系统工具，是对/bin系统下的补充。
- /usr/sbin目录存储的是在/usr目录被挂载后才需要的程序。
* 第四章 笨出来的文化和哲学
** 万般皆文本
- linux中除了可以执行的文件，其他的一切几乎都是文本，如存储用户名和密码的passwd文件、存储图片的xmp文件等。
- xmp：linux下最常见的图片格式之一，最初是为X windows而设计的，是由c语言的语法构成的纯文本文件，可以直接包含在c语言程序中。
*** 配置文件的DSV风格
所有的配置文件都有一个统一的风格——DSV
- DSV：Delimiter-Separated Values的缩写，翻译过来是“分隔符分隔值”，含义是使用“分隔符”将一个一个的“值”分割开来，便于取值处理。“值”也可以理解为“字段”
** linux中的配置文件
*** 配置三元素
- 配置文件
- 环境变量
- 命令行选项
**** 详细的划分（系统级别和用户级别的区分）
- 系统配置文件、系统环境变量
- 用户配置文件、用户环境变量
- 命令行选项
**** 三者的顺序
系统级别的优先级最高，命令选项优先级最低
**** 三者的响应顺序
命令行 > 用户级别 > 系统级别
**** 选择配置机制的原则
- 调用时可能发生变化的配置信息 —— 使用命令行选项;
- 改动很少但确实应该由各个用户控制的配置信息 —— 使用用户配置文件或用户环境变量;
- 需要由系统管理员设置而不需要用户改变的整体系统级选项数据 ——系统级配置文件或系统级环境变量;
*** 配置文件
- 配置文件的含义：学名是“运行控制文件”，存放与具体程序相关的声明信息，有时甚至是可执行文件，在程序启动时解析
- 配置文件的位置：
  - 系统级别的配置文件，放置在/etc下。
  - 用户界别的配置文件，放置在home目录下，并且一般都是隐藏文件（以 . 开头），一般称为点文件。
  - 配置文件的命名方式：命名方式没有严格规定，基本与程序名称一致。
  - 古老的命名约定：可执行文件名后加“rc”后缀（rc代表运行控制），如/etc/bashrc和.bashrc，前者是bash的系统配置文件，后者是bash的用户配置文件
*** 环境变量 
当linux程序启动时，它的运行环境会包含一组名字和值（名字和值都是字符串），有些是由用户手工设置的，有些是由系统在登陆时设置的，有些是由shell或虚拟终端设置的，这就是环境变量。linux下，环境变量一般会携带文件搜索路径、系统默认值、当前用户ID和进程ID等信息。
**** 常见的系统环境变量
| 变量名  | 用途                                                                                                |
|---------+-----------------------------------------------------------------------------------------------------|
| USER    | 当前会话登陆的帐户名（BSD约定）                                                                     |
| LOGNAME | 当前会话登陆的帐户名（System V约定                                                                  |
| HOME    | 当前会话的用户home目录                                                                              |
| COLUMNS | 文本控制台或虚拟窗口以字符为单位的列数，通过这个环境变量，CLI的程序可以了解一行内最多能输出多少字符 |
| LINES   | 文本控制台或虚拟终端窗口以字符为单位的行数，通过这个环境变量，CLI的程序可以了解屏幕上最多可以显示多少行文本 |
| SHELL   | 当前使用的shell的名字                                                                                       |
| PATH    | shell搜索可执行程序的目录列表                                                                               |
| TERM    | 当前会话控制台或虚拟终端的名称。最大的用途就是程序能够知道可以使用哪些特性，比如是否可以输出中文等。                                                          |
* 第五章 shell脚本编程
** 第一个shell脚本程序
*** 程序代码
#+BEGIN_QUOTE
#！/bin/sh
# My first script
echo “Hello World！
#+END_QUOTE

*** 注解：
- #开头的是注释
- #!第一行是脚本解释程序的声明指令，由调用这个脚本的shell来检测，仅在脚本第一行才有效。
- 要使脚本能够执行，需要使用chmod命令赋予可执行权限，比如 ： chmod 755 ……
*** 变量
- 变量的命名规则
  - 首个字符必须为字母
  - 中间不能有空格，可以使用下划线
  - 不能使用标点符号
  - 不能使用bash里的关键字（可以使用help命令查看保留关键字）
- 变量的调用
   使用$直接调用变量
*** 运算
**** expr用于整数值运算，每一项用空格隔开
#+BEGIN_QUOTE
weight=`expr $weight + 1`
#+END_QUOTE
一个注意事项：*在shell中 有特殊意义，应该写成“\*”，或者用双括号“”括起来。
**** let表示数学运算
#+BEGIN_QUOTE
let "weight+=1"
let "weight = weight+1"
#+END_QUOTE
**** (())方法和let一样
#+BEGIN_QUOTE
((weight+=1))
#+END_QUOTE
**** $[] 将中括号中的表达式作为数学运算先计算结果再输出
** 脚本的基本要素
*** 变量
- shell中变量无需事先声明;
- 看到以$开头的单词，会寻找变量的值，然后代替
**** 变量的命名规则
- 首个字符必须为字母
- 中间不能有空格，可以使用（_）
- 不能使用标点符号
- 不能使用basn里的关键词
**** 引号（“”）内的变量
- 引号内的变量 加上$后，仍然是取值
**** 用{}明确变量名
如 ${sum}apples
*** 运算
#+BEGIN_QUOTE
脚本仅仅提供了整数的数学运算\\
weight=1
weight=weitht+1
echo $weitht

得到的结果不是2,  而是1+1， 直接相加相当于是字符的连接
#+END_QUOTE
**** 数学运算的表达式
- expr：用于整数值运算，每一项用空格隔开
#+BEGIN_QUOTE
weigt='exper $weight + 1'
#+END_QUOTE

- let：表示数学运算
#+BEGIN_QUOTE
let "weight+=1" 或 let "weight=$weight+1"
#+END_QUOTE

- (()) ：用法和let类似
#+BEGIN_QUOTE
((weight+=1)) 或 ((weight=$weight+1))
#+END_QUOTE

- $[ ]：将中括号内的表达式作为数学运算先计算结果再输出

- 乘法 * 运算的表达
因为 * 在shell中有特殊意义，用\*表示乘法.
*** 流程控制
**** if语句
1. 第一种
#+BEGIN_QUOTE
if condition ; then
    commands
fi
#+END_QUOTE

2. 第二种
#+BEGIN_QUOTE
if condition ; then
    commands
fi
#+END_QUOTE

3. 第三种
#+BEGIN_QUOTE
if condition1 ; then
    command1
elif condition2 ; then
    command2
fi
#+END_QUOTE
**** test语句
test语句返回的是exit状态（即true和false），经常和if语句一起使用，作为if的条件
***** test的两种形式
1. 第一种形式
test expression
2. 第二种形式（这种形式经常配合if语句）
[  expression  ]
*方括号和expressio之间必须有空格*
***** 实际例子
#+BEGIN_QUOTE
……
if [  -z "$1"  ] ; then
    ……
fi
#+END_QUOTE

**** exit语句
- exit 0 —— 退出脚本，状态值为0（成功）
- exit 1 —— 退出脚本，状态值为1（失败）
**** case语句
case表达式用来匹配一个给定的字符串，而不是数字
* 第七章 编辑器
** vi
暂时未做笔记
** emacs
*** emacs的来历
emacs是由 Richard Stallman于1975年在MIT人工智能实验室与 Guy Lewis Steele Jr 共同开发出来的。（p274）
*** buffer、window、frame
**** buffer
文件在内存中的表示，Emacs并不直接对文件进行操作，而是把文件加载到Buffer中供用户操作。只有当用于确定要把在Buffer中所做的修改写入文件时，即执行“save-buffer”命令时，Emacs才把Buffer中的内容写入文件。
**** window
Buffer的显示区域，或者说是view。
**** Frame
Emacs的实际窗口。一个Frame中可以包含多个Window，每个Window显示一个Buffer的内容。
*** emscs的基本使用
*emacs 常用的快捷键*
| 命令                       | 快捷键     | 功能                                       |
|----------------------------+------------+--------------------------------------------|
| move-beginning-of-line     | c-a        | 光标移动到行首                             |
| move-end-of-line           | c-e        | 光标移动到行尾                             |
| forward-char               | c-f        | 光标右移一个字符                           |
| backward-char              | c-b        | 光标左移一个字符                           |
| next-line                  | c-n        | 光标下移一行                               |
| previous-line              | c-p        | 光标上移一行                               |
| forward-word               | m-f        | 光标右移一个单词                           |
| backward-word              | m-b        | 光标左移一个单词                           |
| beginning-of-buffer        | m-<        | 光标移动到文件开头                         |
| end-of-buffer              | m-<        | 光标移动到文件末尾                         |
| scroll-up                  | c-v        | 光标移动到下一页                           |
| scroll-down                | m-v        | 光标移动到上一页                           |
| set-mark-command           | c-space    | 开启标记模式，切换到选中状态               |
| mark-whole-buffer          | c-x h      | 文档全选                                   |
| kill-region                | c-w        | cut 剪切操作                               |
| kill-ring-save             | m-w        | copy 复制操作                              |
| kill-line                  | c-k        | 删除光标到行尾的所有内容                   |
| delete-char                | c-d        | 删除光标所在字符                           |
| delete-backward-char       | 退格键     | 删除光标前的字符                           |
| yank                       | c-y        | past 粘帖操作                              |
| yank-pop                   | m-y        | 粘帖剪切板中的上个内容，循环剪切板中的内容 |
| undo                       | c-x u或c-_ | 撤销                                       |
| isearch-forward            | c-s        | 向下搜索                                   |
| isearch-backward           | c-r        | 向上搜索                                   |
| save-buffer                | c-x c-s    | 保存                                       |
| write-file                 | c-x c-w    | 另存                                       |
| save-buffers-kill-terminal | c-x c-c    | 保存并退出                                 |
| switch-to-buffer           | c-x b      | 切换已经打开的文件                         |
| kill-buffer                | c-x k      | 关闭已经打开的文件                                  | 

*emacs获取帮助命令的快捷键*
| 命令              | 快捷键 | 功能                           |
|-------------------+--------+--------------------------------|
| describe-variable | c-h v  | 查看某个内置Lisp变量的说明文档 |
| describe-function | c-h f  | 查看某个内置命令的说明文档     |
| describe-mode     | c-h m  | 查看当前buffer对应的mode的说明文档 |
| describe-key      | c-h k  | 查看某个快捷键对应的命令           |
| where-is          | c-h w  | 查看某个命令绑定的快捷键           |
| describe-bindings | c-h b  | 查看当前buffer所有的快捷键列表     |
| find-function     | 无     | 查看某个内置命令的Lisp源代码       |
| find-variable     | 无     | 查看某个内置变量的Lisp源代码       |
| Apropos           | 无     | 模糊查询内置命令或变量的说明文档                   |
*** Lisp语言
- Lisp是世界上第一个函数性编程语言
- Lisp只有两种基本的数据
- Lisp只有唯一的一种基本语法结构——表达式
**** Lisp的原子和表
- Lisp的表达式是由一个原子（atom）或表（list）构成。
- 原子（atom）由符号（symbol）和数值（number）构成。
- 表是由零个或多个表达式组成的串行，表达式之间用空格分开，放入一对括号中
- 原子和表：
abc ; 原子\\
（）   ;  空表\\
（abc xyz）; 包含两个原子的表\\
（a b （c）d）; 包含四个原子的表，其中第三个原子本身也是表，这种表称为嵌套表。
**** Lisp中的表达式
如果表达式是一个表，把表中的第一个元素叫做操作符，其余的元素叫做自变量。在lisp中，1+1的表达式的写法是：\\
          (+ 1 1)
* 第九章 特种文件系统
** 日志和ReiserFS
*** 理解日志
1. 元数据
元数据就是诠释数据的数据。  作为文件系统，一定要提供存储、查询和处理数据的功能。  文件系统内部就保存了一个内部数据结构，使得这些操作成为可能，这个内部数据结构就是元数据，他为文件系统提供特定的身份和性能特征。

元数据对于大部分人来说是不必关心的，因为元数据是专门交给文件系统的驱动程序使用的。  想要文件系统的驱动程序好好干活，它就得轻松愉快的找到元数据。  有三个要求：
- 合理
- 一致
- 无干扰

做不到这三点的话，驱动程序就无法理解元数据，也操作不了，那么，就只能跟文件系统说拜拜了。  

文件系统是文件系统，文件系统的驱动程序是文件系统的驱动程序，不是一码事

2. fsck
fsck确保文件系统驱动程序要用的元数据是干净的

每次linux启动，在没有挂接任何文件系统的时候都会启动fsck扫描/etc/fstab 文件中列出的本地文件系统；  每次linux关闭，它要把还在内存中的被称之为页面缓存中的数据传送到磁盘，还要保证把已经挂接的文件系统卸载干净。

3. fsck的问题
当linux遇到异常关机，重启后，fsck就会发现文件系统没有卸载赶紧，对应的元数据可能不干净，已经出了问题，于是fsck开始全面审查元数据，修正一切可以修正的错误，文件系统又可以正常使用了。fsck不能修复的数据，直接丢掉，且fsck全面扫描元数据，是需要长时间的运算的，这是fsck最大的弊病。

4. 日志（一个比fsck更好的解决方案）
